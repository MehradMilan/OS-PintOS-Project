# تمرین گروهی ۱.۱ - مستند طراحی

گروه
-----
 > نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علیرضا نوروزی noroozi.alirezaa@gmail.com

نام و نام خانوادگی <example@example.com> 

نام و نام خانوادگی <example@example.com> 

نام و نام خانوادگی <example@example.com> 

مقدمات
----------
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  بنویسید.

> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

پاس‌دادن آرگومان
============
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

نیاز داریم تا ورودی تایع `process_execute` را گرفته و با کاراکتر فاصله (`' '`) به‌اصطلاح توکنایز کنیم. همچنین یک حد بالا نیز برای طول رشته ورودی داریم. درنهایت برای Initialize کردن `argv` به یک حد بالا از تعداد آرگومان‌های ورودی نیز نیاز داریم.

```c
#define DELIMITER " "
```

```c
#define COMMAND_MAX_LEN 2048
```

```c
#define ARGS_MAX_COUNT 64
```

خروجی نیز دو متغیر به شکل زیر می‌باشد:

```c
int argc;
char *argv[ARGS_MAX_COUNT];
```

optional
-------

می‌توانیم آدرس هرکدام از اعضای `argv` را نیز در یک ‌آرایه جدا ذخیره کنیم. به‌هنگام استخراج آرگومان‌ها این آرایه نیز پر می‌شود.

```c
char* addrs;
```

الگوریتم‌ها
------------
> به‌طور خلاصه توضیح دهید چگونه آرگومان‌ها را پردازش کرده‌اید؟ چگونه اعضای `argv[]` را به ترتیب درست در پشته قرار داده‌اید؟ و چگونه از سرریز پشته جلوگیری کرده‌اید؟

با استفاده از `strtok_r` رشته ورودی را با `DELIMITER` جدا می‌کنیم و به ترتیب وارد `argv` می‌کنیم و در هرمرحله یکی به مقدار `argc` اضافه می‌کنیم.

بعد از اجرای تایع `setup_stack` عملیات پر کردن استک با اعضای `argv` انجام می‌شود.
ابتدا فضای موردنیاز را به استک می‌دهیم. آرگومان‌های موجود در `argv` را به‌صورت معکوس وارد استک می‌کنیم (و مقدار  `esp` نیز طبیعتا در هر مرحله کاهش می‌یابد.) اگر یوینتر به استک اصطلاحا `word aligned` نباشد، مقدار `NULL` را وارد استک می‌کنیم تا `align` شود. در نهایت بعد از پوش شدن همه توکن‌ها یک مقدار `NULL` وارد استک می‌کنیم که نشانگر اتمام توکن‌های `argv` می‌باشد. حال مقادیر `addrs` که آدرس آرگومان‌ها بود را به‌صورت معکوس  وارد استک می‌کنیم. در مرحله بعد آدرس `argv` و بعد از آن `argc` را وارد استک می‌کنیم. در نهایت آدرس بازگشت وارد استک می‌شود.

قابل ذکر است عملیات درج در استک با `memset` یا `memcpy` انجام می‌شود.

متغیرهای `COMMAND_MAX_LEN` و `ARGS_MAX_COUNT` برای جلوگیری از بزرگ‌شدن حجم استک قرار داده‌شده اند و طول ورودی و تعداد آرگومان‌ها چک می‌شوند.


منطق طراحی
-----------------
> چرا Pintos به‌جای تابع‌ `strtok()` تابع‌ `strtok_r()` را پیاده‌سازی کرده‌است؟

```c
char *strtok(char *str, const char *delim) {
    static char *save;
    return strtok_r(str, delim, &save);
}
```
با رجوع به کد مرجع `strtok` می‌توان فهمید در فراخوانی‌های مجدد، `save` مقداردهی اولیه نمی‌شود. همچنین `strtok_r` برخلاف `strtok` یک تابع `reentrant` است و قابلیت `Thread safety` را داراست. بدین معنی که `state` ورودی را در یک بافر غیر استاتیک (`saveptr`) ذخیره می‌کند که توسط ریسه‌های دیگر تغییر نمی‌کند.

<div dir="ltr">

The **saveptr** (**save**) argument is a pointer to a `char *` variable that is used internally by `strtok_r()` in order to maintain context between
       successive calls that parse the same string.

</div>


> در Pintos عمل جدا کردن نام فایل از آرگومان‌ها، در داخل کرنل انجام می‌شود. در سیستم عامل‌های برپایه‌ی Unix، این عمل توسط shell انجام می‌شود. حداقل دو مورد از برتری‌های رویکرد Unix را توضیح دهید.

<!-- <div dir="rtl"> -->

۱. دسترسی‌های فضای کرنل بیشتر از فضای کاربر (در اینجا `shell`) می‌باشد. در این حالت نگرانی‌های امنیتی نیز پایین است. (`security`)

۲. عملیات `parse` به یک شیوه واحد انجام نمی‌شود و هر کابر و `shell` می‌تواند `parser` خود را داشته باشد. (`flexibility`)

۳. تمرکز کرنل روی اجرای دستورات است و بقیه ملاحظات در سطح `shell` انچام می‌گیرد و پیچیدگی‌ای به کرنل اضافه نمی‌شود. (`efficiency`)

<!-- </div> -->

فراخوانی‌های سیستمی
================
داده‌ساختار‌ها
----------------
> در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ای.جاد کرده‌اید یا تغییر داده‌اید را بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

- In `pintos/src/userprog/syscall.h` and `pintos/src/userprog/syscall.c`, the following functions will be added:
```c
int sys_practice (int i);
int sys_halt (void);
int sys_exit (int status);
pid_t sys_exec (const char *cmd line);
int sys_wait (pid_t pid);
```

- In `pintos/src/threads/thread.h`, the following struct will be created:
```c
struct thread_status 
  {
    int exit_code;              /* Child’s exit code. */
    struct semaphore sema;      /* Initialized to 0. Decrement by parent on wait and increment by child on exit. */ 
    int ref_count;              /* Initialized to 2. Decrement if either child or parent exits. */
    struct lock lock;           /* Lock to protect EXIT_CODE and REF_COUNT. */
    struct list_elem elem;      /* Stored in parent thread. */
    tid_t tid;                  /* Child thread's id. */
  }
```

- In `struct thread`, the following attributes will be added:
```c
struct list child_es_list;      /* List of the exit statuses of child threads. */
struct exit_status es;          /* The thread’s own exit status. */
```

- In `userprog/syscall.c`, the following attributes will be added:
```c
void *validate_addr (void *ptr); /* If the address is valid, return it. Otherwise exit(1). */
```

> توضیح دهید که توصیف‌کننده‌های فایل چگونه به فایل‌های باز مربوط می‌شوند. آیا این توصیف‌کننده‌ها در کل سیستم‌عامل به‌طور یکتا مشخص می‌شوند یا فقط برای هر پردازه یکتا هستند؟

مدیریت توصیف‌کننده های فایل: برای جایگذاری درست توصیف‌کننده های فایل، برای هر پروسه، یک آرایه به طول 1024 خواهیم داشت که شماره توصیف‌کننده های آماده را نگهداری کند، برای اندیس هایی که یک هستند به آنها `1` توصیف‌کننده فایل نسبت میدهیم و به غیر آن ها `0` میدهیم، پس برای ابتدا کل ارایه را کامل با 0 پر میکنیم و برای هر پروسه خانه اول را `STDIN_FILENO`، خانه دوم را با `STDOUT_FILENO`، حال هر وقت خواستیم اضافه کنیم توصیف‌کننده جدیدی را، پیمایش میکنیم تا یکی که  `1` نباشد، و آنرا اضافه میکنیم. و آپدیت کردن آرایه در فراخوانی توابع `add_file` و `remove_file` استفاده میشود.

الگوریتم‌ها
------------
> توضیح دهید خواندن و نوشتن داده‌های کاربر از داخل هسته، در کد شما چگونه انجام شده است.

- قبل از هر عملیات فراخوانی که با استفاده از تابع `syscall_handler`, باید یک تابع `validate_addr()` را فراخوانی کنیم تا صحت سنجی آدرس ورودی انجام شود، اگر نبود از پروسه خارج میشویم.
- بعد از صحت سنجی آدرس ها باید یک `filesys_lock` بگذاریم تا هیچ فراخوانی سیستمی به صورت هم روند اجرا نشوند تا مشکلی برای دیتا بوجود نیاید، پس از آن دیتای مورد نظر و کاری که باید انجام دهیم از `argv` خوانده میشود و تابع مورد نظر آن صدا زده میشود.
- توجه کنید که بعد از پایان فراخوانی باید `filesys_lock` را رها کنیم تا برنامه ها به ادامه خود بپردازند.

> فرض کنید یک فراخوانی سیستمی باعث شود یک صفحه‌ی کامل (۴۰۹۶ بایت) از فضای کاربر در فضای هسته کپی شود. بیشترین و کمترین تعداد بررسی‌‌های جدول صفحات (page table) چقدر است؟ (تعداد دفعاتی که `pagedir_get_page()` صدا زده می‌شود.) در‌ یک فراخوانی سیستمی که فقط ۲ بایت کپی می‌شود چطور؟ آیا این عددها می‌توانند بهبود یابند؟ چقدر؟

> پیاده‌سازی فراخوانی سیستمی `wait` را توضیح دهید و بگویید چگونه با پایان یافتن پردازه در ارتباط است.

در تابعی که در بالا هم اضافه کردیم به `syscall` به نام `process_wait` تمام منطق در آن پیاده سازی میشود.
- باید ابتدا چک کنیم که رسته با id داده شده در بین `children` ها باشد وگرنه `-1` برگردانیم.
- اگر وجود داشت `sema_down` را برابر `dead` در `thread_status ` میذاریم.
- بعد از `sema_down` باید  `exit_code` را برابر مقدار آن در بچه هایش بگذاریم.
- سپس `lock` را برای بچه هایش قرار میدهیم و `ref_cnt` را یکی کم میکنیم.

> هر دستیابی هسته به حافظه‌ی برنامه‌ی کاربر، که آدرس آن را کاربر مشخص کرده است، ممکن است به دلیل مقدار نامعتبر اشاره‌گر منجر به شکست شود. در این صورت باید پردازه‌ی کاربر خاتمه داده شود. فراخوانی های سیستمی پر از چنین دستیابی‌هایی هستند. برای مثال فراخوانی سیستمی `write‍` نیاز دارد ابتدا شماره‌ی فراخوانی سیستمی را از پشته‌ی کاربر بخواند، سپس باید سه آرگومان ورودی و بعد از آن مقدار دلخواهی از حافظه کاربر را (که آرگومان ها به آن اشاره می کنند) بخواند. هر یک از این دسترسی ها به حافظه ممکن است با شکست مواجه شود. بدین ترتیب با یک مسئله‌ی طراحی و رسیدگی به خطا (error handling) مواجهیم. بهترین روشی که به ذهن شما می‌رسد تا از گم‌شدن مفهوم اصلی کد در بین شروط رسیدگی به خطا جلوگیری کند چیست؟ همچنین چگونه بعد از تشخیص خطا، از آزاد شدن تمامی منابع موقتی‌ای که تخصیص داده‌اید (قفل‌ها، بافر‌ها و...) مطمئن می‌شوید؟ در تعداد کمی پاراگراف، استراتژی خود را برای مدیریت این مسائل با ذکر مثال بیان کنید.

همگام‌سازی
---------------
> فراخوانی سیستمی `exec` نباید قبل از پایان بارگذاری فایل اجرایی برگردد، چون در صورتی که بارگذاری فایل اجرایی با خطا مواجه شود باید `-۱` برگرداند. کد شما چگونه از این موضوع اطمینان حاصل می‌کند؟ چگونه وضعیت موفقیت یا شکست در اجرا به ریسه‌ای که `exec` را فراخوانی کرده اطلاع داده می‌شود؟

> پردازه‌ی والد P و پردازه‌ی فرزند C را درنظر بگیرید. هنگامی که P فراخوانی `wait(C)` را اجرا می‌کند و C  هنوز خارج نشده است، توضیح دهید که چگونه همگام‌سازی مناسب را برای جلوگیری از ایجاد شرایط مسابقه (race condition) پیاده‌سازی کرده‌اید. وقتی که C از قبل خارج شده باشد چطور؟ در هر حالت چگونه از آزاد شدن تمامی منابع اطمینان حاصل می‌کنید؟ اگر P بدون منتظر ماندن، قبل از C خارج شود چطور؟ اگر بدون منتظر ماندن بعد از C خارج شود چطور؟ آیا حالت‌های خاصی وجود دارد؟

منطق طراحی
-----------------
> به چه دلیل روش دسترسی به حافظه سطح کاربر از داخل هسته را این‌گونه پیاده‌سازی کرده‌اید؟

> طراحی شما برای توصیف‌کننده‌های فایل چه نقاط قوت و ضعفی دارد؟

> در حالت پیش‌فرض نگاشت `tid` به `pid` یک نگاشت همانی است. اگر این را تغییر داده‌اید، روی‌کرد شما چه نقاط قوتی دارد؟

سوالات افزون بر طراحی
===========
> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی(esp) نامعتبر استفاده کرده است بیابید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.

> تستی را که هنگام اجرای فراخوانی سیستمی از یک اشاره‌گر پشته‌ی معتبر استفاده کرده ولی اشاره‌گر پشته آنقدر به مرز صفحه نزدیک است که برخی از آرگومان‌های فراخوانی سیستمی در جای نامعتبر مموری قرار گرفته اند مشخص کنید. پاسخ شما باید دقیق بوده و نام تست و چگونگی کارکرد آن را شامل شود.یک قسمت از خواسته‌های تمرین را که توسط مجموعه تست موجود تست نشده‌است، نام ببرید. سپس مشخص کنید تستی که این خواسته را پوشش بدهد چگونه باید باشد.

سوالات نظرخواهی
==============
پاسخ به این سوالات اختیاری است، ولی پاسخ به آن‌ها می‌تواند به ما در بهبود درس در ترم‌های آینده کمک کند. هر چه در ذهن خود دارید بگویید. این سوالات برای دریافت افکار شما هستند. هم‌چنین می‌توانید پاسخ خود را به صورت ناشناس در انتهای ترم ارائه دهید.

> به نظر شما، این تمرین یا هر یک از سه بخش آن، آسان یا سخت بودند؟ آیا وقت خیلی کم یا وقت خیلی زیادی گرفتند؟

> آیا شما بخشی را در تمرین یافتید که دید عمیق‌تری نسبت به طراحی سیستم عامل به شما بدهد؟

> آیا مسئله یا راهنمایی خاصی وجود دارد که بخواهید برای حل مسائل تمرین به دانشجویان ترم‌های آینده بگویید؟

> آیا توصیه‌ای برای دستیاران آموزشی دارید که چگونه دانشجویان را در ترم‌های آینده یا در ادامه‌ی ترم بهتر یاری کنند؟

> اگر نظر یا بازخورد دیگری دارید در این قسمت بنویسید.
