تمرین گروهی ۳ - مستند طراحی
======================

گروه: ۶
-----

>>‫نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

علیرضا نوروزی noroozi.alirezaa@gmail.com

محمدحسین علی‌حسینی alihosseini@sharif.edu 

مهراد میلانلو milanloomehrad@gmail.com

پرنیان رضوی‌پور razaviparnian81@yahoo.com


مقدمات
----------

>>‫ ‫‫اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت  ‫بنویسید.

>>‫ لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع‫ ‫درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

بافر کش
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را‫ بنویسید و دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.


```c
struct cache_block {
	block_sector_t sector_index;
	bool valid_block;
	bool dirty_block;
	char data[BLOCK_SECTOR_SIZE];
	struct lock rw_lock;
	struct list_elem elem;
}

struct list cache;
struct lock cache_lock;
struct cache_block cache_block[64];		// buffer cache size is 64
```
الگوریتم‌ها
------------

>>‫ توضیح دهید که الگوریتم مورد استفاده‌ی شما به چه صورت یک بلاک را برای جایگزین ‫ شدن انتخاب می‌کند؟

برای پیاده‌سازی `LRU` نیاز داریم تابلاک‌ها بر اساس آخرین زمان دسترسی مرتب شوند. برای این‌کار بلاک‌هایی که آخرین بار به آن‌ها دسترسی داشتیم را به سر لیست اضافه می‌کنیم. با این شرایط تضمین می‌شود بلاک‌ها به ترتیب زمان مرتب و درون لیست قرار می‌گیرند.

>>‫ روش پیاده‌سازی `read-ahead` را توضیح دهید.

در پیاده‌سازی کش، به اندازه داده مدنظر داده را از دیسک نمی‌خوانیم؛ بلکه به اندازه یک بلاک دیتا با اندازه خاص خوانده شده و در بافر قرار می‌گیرد. پیاده‌سازی `read-ahead` نیز چنین است.

همگام سازی
-------------

>>‫ هنگامی که یک پردازه به طور مستمر در حال خواندن یا نوشتن داده در یک بلاک بافرکش‫ می‌باشد به چه صورت از دخالت سایر پردازه‌ها جلوگیری میشود؟

هر ریسه یک `lock` دارد که هنگام دسترسی به `cache_block` ابتدا قفل را می‌گیرد که سایر ریسه‌ها نتوانند به‌صورت همزمان به داده آن سکتور دسترسی نداشته باشند.

>>‫ در حین خارج شدن یک بلوک از حافظه‌ی نهان، چگونه از پروسه‌های دیگر جلوگیری می‌شود تا‫ به این بلاک دسترسی پیدا نکنند؟

هر دسترسی به دیسک نیاز به دست‌یابی به `lock` دارد. برای همین پروسه‌های دیگر نمی‌توانند به آن بخش از دیسک دسترسی داشته باشند.

منطق طراحی
-----------------

>>‫ یک سناریو را توضیح دهید که از بافر کش، `read-ahead` و یا از `write-behind` استفاده کند.

`read-ahead`: فرض کنید روی یک آرایه بزرگ حلقه `for` می‌زنیم و با یک عدد جمع می‌کنیم. یک بلاک از دیتا وارد کش می‌شوند که شامل تعدادی از خانه‌های آرایه می‌باشد و در هر بار از پیمایش حلقه، نیاز به دسترسی به دیسک نیست.

`write-ahead`: فرض کنید داده‌ای با حجم زیاد داریم و می‌خواهیم به سیستم وصل شده و داده‌ را دریافت کنیم. از آنجایی که هزینه شبکه بیشتر از cpu و یا ram و memory می‌باشد، استفاده از `write-back` بهتر است، اما وجود مشکلاتی مانند از دست دادن کانکشن، باعث می‌شود از `write-ahead` استفاده کنیم.

فایل‌های قابل گسترش
=====================

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

>>‫ بیشترین سایز فایل پشتیبانی شده توسط ساختار inode شما چقدر است؟

همگام سازی
----------

>>‫ توضیح دهید که اگر دو پردازه بخواهند یک فایل را به طور همزمان گسترش دهند، کد شما چگونه از‫ حالت مسابقه جلوگیری می‌کند.

>>‫ فرض کنید دو پردازه‌ی A و B فایل F را باز کرده‌اند و هر دو به end-of-file اشاره کرده‌اند.‫ اگر  همزمان A از F بخواند و B روی آن بنویسد، ممکن است که A تمام، بخشی یا هیچ چیز از‫ اطلاعات نوشته شده توسط B را بخواند. همچنین A نمی‌تواند چیزی جز اطلاعات نوشته شده توسط B را‫ بخواند. مثلا اگر B تماما ۱ بنویسد، A نیز باید تماما ۱ بخواند. توضیح دهید کد شما چگونه از‫ این حالت مسابقه جلوگیری می‌کند.

>>‫ توضیح دهید همگام سازی شما چگونه "عدالت" را برقرار می‌کند. فایل سیستمی "عادل" است که‫ خواننده‌های اطلاعات به صورت ناسازگار نویسنده‌های اطلاعات را مسدود نکنند و برعکس. بدین ترتیب‫ اگر تعدادی بسیار زیاد پردازه‌هایی که از یک فایل می‌خوانند نمی‌توانند تا ابد مانع نوشده شدن‫ اطلاعات توسط یک پردازه‌ی دیگر شوند و برعکس.

منطق طراحی
----------

>>‫ آیا ساختار `inode` شما از طبقه‌بندی چند سطحه پشتیبانی می‌کند؟ اگر بله، دلیل خود را برای‫ انتخاب این ترکیب خاص از بلوک‌های مستقیم، غیر مستقیم و غیر مستقیم دوطرفه توضیح دهید.‌‫ اگر خیر، دلیل خود برای انتخاب ساختاری غیر از طبقه‌بندی چند سطحه و مزایا و معایب ساختار‫ مورد استفاده خود نسبت به طبقه‌بندی چند سطحه را توضیح دهید.

زیرمسیرها
============

داده‌ساختار‌ها و توابع
---------------------

>>‫ در این قسمت تعریف هر یک از `struct` ها، اعضای `struct` ها، متغیرهای سراسری‫ یا ایستا، `typedef` ها یا `enum` هایی که ایجاد کرده‌اید یا تغییر داده‌اید را بنویسید و‫ دلیل هر کدام را در حداکثر ۲۵ کلمه توضیح دهید.

We add a pointer to the working directory of `thread` in its struct. This way we can access to the `CWD` of each thread.

`thread.h:`
```C
struct thread
{
	...
    struct dir *cwd;
	...
}
```
We also add a bool variable to the `inode_disk` struct to determine whether an inode is containing a directory on the disk or not.

`inode.c:`
```C
struct inode
  {
    ...
	bool is_dir;
	...
  };
```
We add an `lock` for each directory. Also, we add `parent_dir` to the `struct dir`. Therefore we can access the parent directories easily by recursion. There is `use_cnt` parameter that shows number of processes that are using this directory.

`directory.c:`
```C
struct dir
  {
    ...
	struct dir *parent_dir;
	int use_cnt;
	struct lock *lock;
	...
  };
```


الگوریتم‌ها
-----------

>>‫ کد خود را برای طی کردن یک مسیر گرفته‌شده از کاربر را توضیح دهید.‫ آیا عبور از مسیرهای absolute و relative تفاوتی دارد؟

To handle both **absolute** and **relative** paths, we start by determining the initial directory.

If we have an absolute path, we use the `dir_open_root()` function provided by Pintos as the starting point (dir) and traverse the path with the `dir_lookup()` function.

If the path is relative, we use the `cwd` defined in each `thread` as the starting point.

In both cases, we use the `get_next_part()` method to obtain the name of the next part and continue recursively to find the corresponding `inode`.


همگام سازی
-------------

>>‫ چگونه از رخ دادن race-condition در مورد دایرکتوری ها پیشگیری می‌کنید؟‫ برای مثال اگر دو درخواست موازی برای حذف یک فایل وجود داشته باشد و ‫ تنها یکی از آنها باید موفق شود یا مثلاً دو ریسه موازی بخواهند فایلی‫ یک اسم در یک مسیر ایجاد کنند و مانند آن.‫ آیا پیاده سازی شما اجازه می‌دهد مسیری که CWD یک ریسه شده یا پردازه‌ای‫ از آن استفاده می‌کند حذف شود؟ اگر بله، عملیات فایل سیستم بعدی روی آن‫ دایرکتوری چه نتیجه‌ای می‌دهند؟ اگر نه، چطور جلوی آن را می‌گیرید؟

We have added a `lock` for each directory to ensure atomic access for any access to the same directory. Therefore each `thread` that wants to access an specified directory, should **acquire** its lock first.

In our implementation, a user process is not allowed to delete a directory if it is the cwd of a running process. This can be ensured by checking `use_cnt` before deleting a directory.

منطق طراحی
-----------------

>>‫ توضیح دهید چرا تصمیم گرفتید CWD یک پردازه را به شکلی که طراحی کرده‌اید‫ پیاده‌سازی کنید؟

To maintain the working directory and efficiently support related operations, we use the `struct dir` since it is not dependent on the name and requires no changes when the working directory name is altered. We have added `struct dir *cwd` to the `thread` data structure to specify the working directory of each thread. When resolving a relative address, we use the `dir_lookup()` function to navigate to the next section, ensuring efficient traversal of the directory tree.

سوال افزون بر طراحی 
============

**write-behind**:

میتوانیم یک timer interupt داشته باشیم که باعث شود ترد در هر مدت زمان مشخصی همه ی سکتور های dirty را به درون دیسک بنویسد و از طرفی با توجه با استراکی برای cache bolck تعریف کرده بودیم ، هر بلاک کش یک  لاک دارد که تایمر اینتراپت باید برای نوشته شدن آن بلاک در دیسک ، آن را آزاد کند و تا حین نوشتن آن بلاک درون دیسک ، ترد دیگری آن را نتواند تغییر دهد .


**read-ahead**:

یک window size دیفالت را درنظر میگیریم. هنگامی که میخواهیم read کنیم ، ابتدا طبق روال عادی چک میکنیم که آیا سکتور مورد نظر از قبل در بافر کش میباشد یا نه، اگر نبود باید از دیسک آن را بخوانیم. سکتور موردنظر را همراه با سکتور های قبل آن و بعد آن (‌به تعداد window size) میخوانیم و سپس همه ی سکتورهای خوانده شده را در بافر کش میگذاریم. حال مثلا یک تابع ایمپلینت میکنیم که با استفاده از track ای که از  عملیات‌های read داشتیم (به همراه شماره ی سکتور های مقصودشان) بررسی می‌کند که آیا سکتور ای که به‌تازگی آن را خوانیم باعث می‌شود که یک پترن sequential داشته باشیم یا خیر (با چک کردن حسابی بودن دنباله! یعنی مثلا سکتوری که به تازگی خواندیم x تا بعد سکتور قبلی و سکتور قبلی نیز x تا قبل سکتور قبلیش هست یا نه... )‌ . اگر تابع موردنظر true ریترن کرد (یعنی دنباله ی حسابی را تشخیص داد ) window size  را افزایش می‌دهیم. در غیر این صورت اگر پترن خاصی وجود نداشته و یک جورایی رندوم می‌باشد ،window size را کاهش می‌دهیم که سکتورهای غیرمفید را الکی نخوانیم و صرفه‌جویی شود.


### سوالات نظرسنجی

پاسخ به این سوالات دلخواه است، اما به ما برای بهبود این درس در ادامه کمک خواهد کرد.

نظرات خود را آزادانه به ما بگوئید—این سوالات فقط برای سنجش افکار شماست.

ممکن است شما بخواهید ارزیابی خود از درس را به صورت ناشناس و در انتهای ترم بیان کنید.

>>‫ به نظر شما، این تمرین گروهی، یا هر کدام از سه وظیفه آن، از نظر دشواری در چه سطحی بود؟ خیلی سخت یا خیلی آسان؟

>> چه مدت زمانی را صرف انجام این تمرین کردید؟ نسبتا زیاد یا خیلی کم؟

>>‫ آیا بعد از کار بر روی یک بخش خاص از این تمرین (هر بخشی)، این احساس در شما به وجود آمد که اکنون یک دید بهتر نسبت به برخی جنبه‌های سیستم عامل دارید؟

>>‫ آیا نکته یا راهنمایی خاصی وجود دارد که بهتر است ما آنها را به توضیحات این تمرین اضافه کنیم تا به دانشجویان ترم های آتی در حل مسائل کمک کند؟

>> متقابلا، آیا راهنمایی نادرستی که منجر به گمراهی شما شود وجود داشته است؟

>>‫ آیا پیشنهادی در مورد دستیاران آموزشی درس، برای همکاری موثرتر با دانشجویان دارید؟

این پیشنهادات میتوانند هم برای تمرین‌های گروهی بعدی همین ترم و هم برای ترم‌های آینده باشد.

>>‫ آیا حرف دیگری دارید؟