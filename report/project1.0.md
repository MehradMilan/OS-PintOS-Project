تمرین گروهی ۱/۰ - آشنایی با pintos
======================

شماره گروه:
-----
> نام و آدرس پست الکترونیکی اعضای گروه را در این قسمت بنویسید.

Mehrad Milanloo <mehrad_milanloo@yahoo.com>

Parnian Razavipour <razaviparnian81@yahoo.com>

Alireza Noroozi <noroozi.alirezaa@gmail.com> 

Hossein Alihosseini <alihosseini@sharif.edu> 

مقدمات
----------
> اگر نکات اضافه‌ای در مورد تمرین یا برای دستیاران آموزشی دارید در این قسمت بنویسید.


> لطفا در این قسمت تمامی منابعی (غیر از مستندات Pintos، اسلاید‌ها و دیگر منابع  درس) را که برای تمرین از آن‌ها استفاده کرده‌اید در این قسمت بنویسید.

آشنایی با pintos
============
>  در مستند تمرین گروهی ۱۹ سوال مطرح شده است. پاسخ آن ها را در زیر بنویسید.


## یافتن دستور معیوب

۱.
According to the contents written in `do-nothing.result` file, program crashes while trying to access the virtual address `0xc0000008`.

۲.
The address of the instruction which leads the program to crash is `eip = 0x8048757`.
(Notice: `eip` stands for `Extended Instruction Pointer` and is used to follow the current instruction running in program.)

۳.
We try to analyze the assembly code of the `do-nothing` binary file generated by running the command below:
```bash
objdump -drS do-nothing
```
Next, we check for the address of instruction that is already obtained and find it in the scope of `_start` function:
```C
void _start (int argc, char *argv[]) {
    ...
}
```
Also, the assembly of the instruction causing the crash is:
```bash
mov 0x24(%esp), %eax
```


۴.
The relevant C code could be found in the `entry.c` file located in `pintos/src/lib/user` address. Here is the code of the function:
```C
void
_start (int argc, char *argv[]) {
  exit (main (argc, argv));
}
```
Before explaining the disassembled instructions, we give a brief explanation of Calling Convention in 80x86.
First, The caller pushes each of the function’s arguments on the stack one by one. Note that the stack grows downward. Meaning each push decrements the stack pointer. Afterwards, the caller pushes the address of its next instruction (the return address) on the stack and jumps to the first instruction of the callee. The callee executes. When it takes control, the stack pointer points to the return address, the first argument is just above it, the second argument is just above the first argument, and so on. If the callee has a return value, it stores it into register `eax`. The callee returns by popping the return address from the stack and jumping to the location it
specifies and finally pops the arguments off the stack.

‌Bases on the above explanation, now we are able to analyze the assembly instructions. (Note that `esp` is the stack pointer register and the usecase of `eax` register is already explained.)

Code:
```
 8048754:	83 ec 1c             	sub    $0x1c,%esp
 8048757:	8b 44 24 24          	mov    0x24(%esp),%eax
 804875b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804875f:	8b 44 24 20          	mov    0x20(%esp),%eax
 8048763:	89 04 24             	mov    %eax,(%esp)
 8048766:	e8 35 f9 ff ff       	call   80480a0 <main>
 804876b:	89 04 24             	mov    %eax,(%esp)
 804876e:	e8 49 1b 00 00       	call   804a2bc <exit>
```

```
#1: sub    $0x1c,%esp
```
#1: This line displaces the stack pointer 28 bytes. Actually it is giving the stack 28 bytes space in memory.

```
#2: mov    0x24(%esp),%eax
```
#2: This instruction is trying to access `argc` argument (first argument of the function) and store it in `eax` register.

```
#3: mov    %eax,0x4(%esp)
```
#3: Now, by this instruction we are able to store the value of `eax` register into the stack as the `argc` argument of the `main` function.

```
#4: mov    0x20(%esp),%eax
```
#4: This instruction is trying to access `argv` argument (second argument of the function) and store it in `eax` register.

```
#5: mov    %eax,(%esp)
```
#5: Now, by this instruction we are able to store the value of `eax` register into the stack as the `argv` argument of the `main` function.

```
#6: call   80480a0 <main>
```
#6: Jumps into `main` function.

```
#7: mov    %eax,(%esp)
```
#7: Stores the output of `main` function which is already in `eax` register, into the stack as the input argument of `exit` function.

```
#8: call   804a2bc <exit>
```
#8: Calls the `exit` function.

۵.
Userprograms start running from the `_start` function in PintOs. As there is no caller function which can call `_start`, so the input arguments haven't been pushed into the stack. The function displaces the stack pointer 36 bytes up to access `argc`.
Remarks: In PintOS, virtual memory is seperated in two parts: First section is Kernel Space which is started from `0` to `PHYS_BASE`.(default value is `0xc0000008`.) Next section belongs to User Space Which is located after the `PHYS_BASE`. As we complained in the previous question, the stack pointer comes up 36 bytes after reserving 28 bytes for the stack. This may lead to crash(`Page Fault: rights violation error`) because it crosses the border of the `User Context` and the `Kernel Context`.

## به سوی crash

۶.
Firstly we'll step into `process_execute()` function by running commands below in GDB:
```bash
  b run_task
  c
  n 3
  step
```
Afterwards, by running the command below, will be able to identify which thread is running the `process_execute()` function:
```bash
info threads
```
The thread we're searching for is the thread with `main` Id.
At the end we will run the `dumplist &all_list thread allelem` command and mention the output which is the set of all the threads present in PintOS at this time. (Containing their struct threds)
```
pintos-debug: dumplist #0: 0xc000e000 {tid = 1, status = THREAD_RUNNING, name = "main", '\000' <repeats 11 times>, stack = 0xc000edec <incomplete sequence \357>, priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
pintos-debug: dumplist #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
```

۷.
Simply apply the `bt` command to print the backtrace. the output is shown below (Containing line of C code corresponding to each function call):
```
#0  process_execute (file_name=file_name@entry=0xc0007d50 \"do-nothing\") at ../../userprog/process.c:36
#1  0xc0020268 in run_task (argv=0xc00357cc <argv+12>) at ../../threads/init.c:288
#2  0xc0020921 in run_actions (argv=0xc00357cc <argv+12>) at ../../threads/init.c:340
#3  main () at ../../threads/init.c:133
```
```C
#0: sema_init (&temporary, 0);
#1: process_wait (process_execute (task));
#2: a->function (argv);
#3: run_actions (argv);
```

۸.
Firstly we'll step into `start_process()` function by running commands below in GDB:
```bash
  b start_process
  c
```
Just as before, we run this command:
```bash
dumplist &all_list thread allelem
```
the result is shown:
```
pintos-debug: dumplist #0: 0xc000e000 {tid = 1, status = THREAD_BLOCKED, name = "main", '\000' <repeats 11 times>, stack = 0xc000eeac "\001", priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0037314 <temporary+4>, next = 0xc003731c <temporary+12>}, pagedir = 0x0, magic = 3446325067}
pintos-debug: dumplist #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc010a020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
pintos-debug: dumplist #2: 0xc010a000 {tid = 3, status = THREAD_RUNNING, name = "do-nothing\000\000\000\000\000", stack = 0xc010afd4 "", priority = 31, allelem = {prev = 0xc0104020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
```
so the threads running `start_process()` funtion are `main`, `idle`, `do-nothing`.

۹.
By tracing the code, it is conculded that the thread is created in the `process_execute` function in `proccess.c` file:
```C
tid_t
process_execute (const char *file_name)
{
  char *fn_copy;
  tid_t tid;

  sema_init (&temporary, 0);
  /* Make a copy of FILE_NAME.
     Otherwise there's a race between the caller and load(). */
  fn_copy = palloc_get_page (0);
  if (fn_copy == NULL)
    return TID_ERROR;
  strlcpy (fn_copy, file_name, PGSIZE);

  /* Create a new thread to execute FILE_NAME. */
  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
  if (tid == TID_ERROR)
    palloc_free_page (fn_copy);
  return tid;
}
```
Here, the calling function, `thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);`, will create a new kernel thread running the start_process function. The code is shown below:
```C
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux)
{
  struct thread *t;
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
  if (t == NULL)
    return TID_ERROR;

  /* Initialize thread. */
  init_thread (t, name, priority);
  tid = t->tid = allocate_tid ();

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
  kf->eip = NULL;
  kf->function = function;
  kf->aux = aux;

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
  ef->eip = (void (*) (void)) kernel_thread;

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
  sf->eip = switch_entry;
  sf->ebp = 0;

  /* Add to run queue. */
  thread_unblock (t);

  return tid;
}
```

۱۰.
We continue debuging untill we reach the `load` function:
```bash
n 6
```
Afterwards, we print the `if_` struct (using command: `print/x if_`) to find `eip` and `esp` values:
```
{edi = 0x0, esi = 0x0, ebp = 0x0, esp_dummy = 0x0, ebx = 0x0, edx = 0x0, ecx = 0x0, eax = 0x0, gs = 0x23, fs = 0x23, es = 0x23 ds = 0x23, vec_no = 0x0, error_code = 0x0, frame_pointer = 0x0, eip = 0x8048754, cs = 0x1b, eflags = 0x202, esp = 0xc0000000, ss = 0x23}
```
So, values are:
`eip = 0x8048754`, `esp = 0xc0000000`.

۱۱.
Firstly, we continue debuging untill we reach executing `iret`:
```bash
n
step
n 6
step
```
The processor needs to enter the `User mode` to run the user program, but x86 processor doesn't support any straightforward solution to context switch. Therefore, `start_process` uses `asm volatile` to call the `intr_exit` function manually. Obviously there is no real interrupt from user mode but now we are in `intr_exit` function in `intr_stubs.S` file which handles the interrupt exit that leads to return from `Kernel mode` to `User mode`. (`iret` command sets the value of some global registers. especially `eip` register which plays the role of `Program Counter` in x86 processor. So by fetching the next instruction, we are back to `User mode` and ready to execute next instruction that is the first line of the user program.)

۱۲.
Using GDB commands, we reach `asm volatile` function and step into it. Then we continue to `iret` and print registers.
```bash
n
step
n 6
step
info registers
```
The output is:
```
eax            0x0      0
ecx            0x0      0
edx            0x0      0
ebx            0x0      0
esp            0xc0000000       0xc0000000
ebp            0x0      0x0
esi            0x0      0
edi            0x0      0
eip            0x8048754        0x8048754
eflags         0x202    [ IF ]
cs             0x1b     27
ss             0x23     35
ds             0x23     35
es             0x23     35
fs             0x23     35
gs             0x23     35
```
As we expected, the output is similar to `if_` struct values. (It only doesn't contain `struct intr_frame`, `vec_no`, `error_code` which are discarded in `intr_exit`).

۱۳.
The commands and their outputs are mentioned below:
Command:
```bash
loadusersymbols tests/userprog/do-nothing
```
Output:
```
add symbol table from file "tests/userprog/do-nothing" at
        .text_addr = 0x80480a0
```
Command:
```bash
bt
```
Output:
```
#0  _start (argc=<unavailable>, argv=<unavailable>) at ../../lib/user/entry.c:8
```
Command:
```bash
disassemble
```
Output:
```
Dump of assembler code for function _start:
=> 0x08048754 <+0>:     sub    $0x1c,%esp
   0x08048757 <+3>:     mov    0x24(%esp),%eax
   0x0804875b <+7>:     mov    %eax,0x4(%esp)
   0x0804875f <+11>:    mov    0x20(%esp),%eax
   0x08048763 <+15>:    mov    %eax,(%esp)
   0x08048766 <+18>:    call   0x80480a0 <main>
   0x0804876b <+23>:    mov    %eax,(%esp)
   0x0804876e <+26>:    call   0x804a2bc <exit>
End of assembler dump.
```
Command:
```bash
stepi
stepi
```
Output:
```
pintos-debug: a page fault exception occurred in user mode
pintos-debug: hit 'c' to continue, or 's' to step to intr_handler
0xc0021b95 in intr0e_stub ()
```
Command:
```bash
bt
```
Output:
```
#0  0xc0021b95 in intr0e_stub ()
```
Command:
```bash:
btpagefault
```
The wanted output:
```
#0  _start (argc=<unavailable>, argv=<unavailable>) at ../../lib/user/entry.c:9
```


## دیباگ

۱۴.
If you look at the `setup_stack` function which is called by `load` function which is also called by ``start_process` function, you can find this line of C code: (All of these functions are located in `process.c` file.)
```C
*esp = PHYS_BASE;
```
`setup_stack` creates a minimal stack by mapping a zeroed page at the top of user virtual memory. this line of code, sets the stack pointer right at the `PHYS_BASE`. As we discussed in Q5, When `_start` tries to access its arguments, it crosses the `PHYS_BASE` and causes `Page Fault`. So if we change the code as below, `do-nothing` test is going to be passed:
```C
*esp = PHYS_BASE - 0x0c;
```
(Note: 4 bytes for argc, 4 bytes for argv, and 4 byte for return address. Therefore we can't pass the `do-stack-align` test. If we consider the 16 byte stack alignment and change to code as below, both tests will pass.)
Final Change:
```C
*esp = PHYS_BASE - 0x24;
```

۱۵.
The program should return `12`.
According to the PintOS documents, the stack should be aligned 16 bytes. (Each block address should end with `0xc`.)
Because we already set the value of `esp` register to `PHYS_BASE - 0x24`, the alignment condtion is established and `esp` always points to an address ending with `0xc`. (16n - 36 = 12 (mod 16))

۱۶.
Running these GDB commands leads to the answer:
```bash
b _start
c
stepi 14
disassemble
x/2xw $esp
```
Output:
```
0xbfffff98:     0x00000001      0x000000a2
```

۱۷.
```
(gdb) print args[0]
$2 = 1 (=0x00000001)
(gdb) print args[1]
$3 = 162 (0x000000a2)
```
Values are same as the prevoius output which were the values on the top of the stack. `args[0]` is syscall code and `args[1]` is the value of `exit status`. (GDB is running `do-nothing` test.)

۱۸.
A semaphore is a synchronization mechanism that allows multiple processes to access a shared resource. It is used to control access to the resource by allowing only one process at a time to access it. The semaphore consists of two operations: `sema_up` and `sema_down`. The purpose of the `temporary semaphore` is to provide a synchronization mechanism between processes. The sema_up and sema_down functions are used to signal and wait for a particular event to occur. The temporary semaphore allows processes to wait until a certain condition is met before continuing execution. This ensures that processes do not interfere with each other, as they must wait for the condition to be met before proceeding.
The sema_up operation increases the value of the semaphore, allowing another process to access the shared resource. The sema_down operation decreases the value of the semaphore, preventing other processes from accessing the shared resource until the current process has finished using it. So obviously sema_up locates in `process_exit` and sema_down locates in `process_wait`.
PintOS runs a user program by calling the `process_execute` function in `init.c` file and passes its return value which is a thread's id to `process_wait`. So that the kernel should wait untill the program ends. (Note: This only supports one user program running at time.)

۱۹.
```bash
b sema_down
c
dumplist &all_list thread allelem
```
The output shows all the threads (with struct) at the time. The `main` thread with located in the adress `0xc000e000` is currently running the program:
```
pintos-debug: dumplist #0: 0xc000e000 {tid = 1, status = THREAD_RUNNING, name = "main", '\000' <repeats 11 times>, stack = 0xc000eeac "\001", priority = 31, allelem = {prev = 0xc0035910 <all_list>, next = 0xc0104020}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
pintos-debug: dumplist #1: 0xc0104000 {tid = 2, status = THREAD_BLOCKED, name = "idle", '\000' <repeats 11 times>, stack = 0xc0104f34 "", priority = 0, allelem = {prev = 0xc000e020, next = 0xc0035918 <all_list+8>}, elem = {prev = 0xc0035920 <ready_list>, next = 0xc0035928 <ready_list+8>}, pagedir = 0x0, magic = 3446325067}
```